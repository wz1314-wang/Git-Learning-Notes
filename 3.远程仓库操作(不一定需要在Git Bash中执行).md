
**前置操作**：git branch -m master main
- 修改当前本地仓库中名为 `master` 的分支名称为 `main`
- 只能修改当前的本地仓库，新仓库仍然是master
- 让后续所有新仓库都默认用 `main`分支： git config --global init.defaultBranch main
- 注意，我的电脑已经执行过了，以后默认均是main分支

```bash
# 先找到该文件夹目录，然后右键，点击Open Git Bash here
git init
git add .
git commit -m "Initial commit: XXX"
```


# 将本地仓库添加到远程仓库

**绑定本地和远程仓库git remote**：给本地的 Git 仓库，和 GitHub 上的远程仓库，建立 “一对一的绑定关系”，并给远程仓库起个叫`origin`的 “快捷小名”
- 告诉本地 Git：“以后提到`origin`，就特指 GitHub 上那个`wz1314-wang/gitlearn.git`仓库”；
- 后续操作远程仓库时，不用再写冗长的 SSH 地址(`git@github.com:wz1314-wang/gitlearn.git`)，直接用`origin`这个小名就行：
    - 把本地代码推到 GitHub：`git push origin main`（不用写完整 SSH 地址）；
    - 从 GitHub 拉取最新代码：`git pull origin main`；
- Git 会通过配置的 SSH Key (私钥和公钥)验证身份
- 验证时，本地用私钥 “开锁”，GitHub 用公钥确认 “钥匙合法”，从而通过验证 —— 整个过程不用输github的账号和密码。
- **对远程仓库进行操作：新增一个远程仓库配置，该远程仓库别名为origin，仓库地址为`git@github.com:wz1314-wang/gitlearn.git`**
```bash
git remote add origin git@github.com:wz1314-wang/gitlearn.git
```

**推送push**：把本地库的所有内容推送到远程库
- 首先在git bash中进入到本地仓库目录
- 然后`git push origin main`把本地`main`分支的内容，推送到远程`origin`仓库的`main`分支
第一次用
```bash
git pull origin main --allow-unrelated-histories # 先拉取远程最新内容到本地（合并差异）
git push -u origin main
```
后续用git push即可，此时git push就相当于下面操作
```bash
git push origin main
```

# 从远程仓库下载项目到本地

**`git clone` 会以 “终端当前所在的路径” 作为父目录，自动在这个父目录下创建一个与远程仓库同名的项目文件夹（比如这里的 `gitskills`），所有项目文件和版本库都会下载到这个文件夹gitskills里**。
```bash
# 首先cd到需要进行该项目的目录下，然后在git clone
git clone git@github.com:michaelliao/gitskills.git
```
- **github上面不显示push的.git文件夹，但是clone到本地后，就可以查看到.git，这个本地`.git`**是 “重构” 出来的，不是远程github中 `.git` 的完全复制****
- git push 推送的不是 .git 文件夹：git push 只推送本地版本库中的 “版本数据”（比如 commit 快照、分支指针、提交历史等），不会推送本地的 .git 文件夹本身。
- GitHub 的 .git 是 “远程自己的”GitHub 仓库的：.git 是 GitHub 后台为这个仓库自动创建的版本库目录，用来存储你 push 上去的版本数据 —— 它不是 “你本地 .git 的副本”，而是远程独立的版本库存储目录，只是 GitHub 界面把它隐藏了。
- **无论是push还是clone，得到的.git均是重构的，而不是原来的.git复制**

