# 创建与合并分支

**查询当前分支**：git branch 
- 前面带有 **星号 `*`** 且颜色通常为 **绿色** 的那个分支，就是你当前所在的分支 

**创建并切换分支：**
```bash
git branch dev # 创建dev分支
git checkout dev # 切换到dev分支,也可以用 git switch dev

git checkout -b dev # 创建并切换到dev分支

# 现在常用做法，创建并切换到dev分支
git switch -c dev
```

**在新分支做修改，不影响原分支内容：**
- 即对一个分支进行的操作，不影响其他分支里的文件内容
- **HEAD 指针**指向的是当前**正在工作的分支**
- **分支指针**（如 `main`、`dev`）指向的是具体的 **提交记录（Commit）**。

|     图片 1      |      图片 2       |
| :-----------: | :-------------: |
| ![[分支切换.png]] | ![[分支切换显示.png]] |
**合并分支：**`git merge`命令用于合并指定分支到当前分支
**合并成功结果**：工作区自动更新为合并后的代码，暂存区干净（即add的内容为空），commit指针指向合并后的
- 内容上，`main` 吸收了 `dev` 的所有改动，即main的工作区内容吸收了dev的工作区内容
- **merge成功后 → 工作区自动更新（完全同步合并结果）**，版本库更新，暂存区更新
```bash
# 切换到需要修改的分支main
git switch main

# 合并前拉取远程仓库origin的main分支最新内容到本地分支main，同步远程仓库的最新内容
git pull origin main

# 合并指定分支dev到当前分支main
git merge dev

# 推送合并后的分支main到远程仓库origin的main分支
git push origin main

```
git pull	等价于 git fetch（拉取远程仓库的最新代码到本地缓存区） + git merge（合并缓存的远程代码到当前本地分支）
`git fetch` = “拉取不合并，工作区、暂存区不变，仅更新「远程缓存分支」（`origin/xxx`），本地分支（如 `main`）不变”；
`git pull` = “拉取 + 合并，工作区、暂存区、版本库更新”。
**只有当修改被 commit 后，切换分支后的工作区才会恢复目标分支（比如 main）原来的内容；未 commit（不管有没有 add），切换分支都会保留修改**



**合并后删除不用的分支：** 
```bash
# 删除本地分支，注意只是删掉dev这个名字（指针），dev的commit记录还存在，可以找到commitID然后通过git switch -c dev <CommitID>恢复该dev名字
git branch -d dev

# 删除远程分支（若需要）
git push origin --delete dev

```

# 解决合并遇到的冲突
**合并时的冲突**：当两个分支**修改了同一个文件的同一行**，或者一个分支删除了文件而另一个分支修改了它时，Git 无法自动决定保留哪个版本，就会把球踢给你，让你手动裁决。

**当git merge dev失败，即发生冲突时，需要手动解决冲突，然后再git add 和git commit，这就相当于合并了分支**。
- 要把两个分支的内容真正合在一起，必须走完这三步：
1. **触发**：`git merge dev`（Git 尝试自动合并并失败）。
2. **执行（人工部分）**：你删掉标记、决定最终代码。**这就是合并的核心操作**。
3. **封口**：`git add` + `git commit`。这一步是把你的合并成果“存档”。

以下是**处理冲突的完整流程**：
**1.发现冲突**
当你执行 `git merge dev` 时，如果发生冲突，终端会显示：
 `Automatic merge failed; fix conflicts and then commit the result.`
此时，你的分支状态会变成 `(main|merging)`。
---
**2.定位并查看冲突**
打开冲突的文件（比如 `readme.txt`），你会看到 Git 自动注入的**冲突标记**：
```Plaintext
<<<<<<< HEAD
这里是你在当前分支（比如 main）修改的内容
=======
这里是你在被合并分支（比如 dev）修改的内容
>>>>>>> dev
```
- **`<<<<<<< HEAD`**：代表你当前所在分支的代码。
- **`=======`**：这是分界线。
- **`>>>>>>> dev`**：代表你要拿过来的那个分支的代码。
---
**3.解决冲突的步骤**
1. **手动编辑**：删掉那些讨厌的 `<<<<<<<`、`=======` 和 `>>>>>>>` 标记。
2. **决定内容**：根据需求，你可以选择保留 `HEAD` 的内容，或者保留 `dev` 的内容，或者把两者结合起来写出一段新内容。
3. **保存文件**：处理完所有冲突标记后，保存文件。
---
**4.提交解决后的结果**
这步非常关键，必须告诉 Git 冲突已经处理完了：
```Bash
git add readme.txt   # 1. 标记冲突已解决
git commit -m "解决合并冲突" # 2. 完成合并提交

# 检查结果：显示dev分支是如何“流进” main分支的
git log --graph --oneline
```
---
**💡 实用小建议**
- **中止合并**：如果你改乱了，想退回到合并前的清爽状态，可以运行 `git merge --abort`。
- **查看冲突文件列表**：如果不记得哪些文件有冲突，运行 `git status`，状态为 `both modified` 的就是冲突文件。

# 分支策略管理no-ff
**1.Fast-forward (默认)：原地跳跃**
当你直接合并（ff）时，Git 认为历史是一条直线。
- **动作**：`main` 分支的指针直接“跳”到 `dev` 分支的最顶端。
- **结果**：没有产生新的提交记录。从历史记录看，就像你一直就在 `main` 上开发一样，`dev` 存在的痕迹消失了。
- **合并后用git log --graph --oneline查看**是一条直线，**没有产生新节点**。
- **删除 dev 分支后git log**历史中**完全找不到** dev 的痕迹
**2.--no-ff (禁用快进)：新建连接**
```bash
git merge --no-ff -m "merge with no-ff" dev
```
当你使用 `--no-ff` 时，Git 会强制执行一次“合并”动作。
- **动作**：Git 会创建一个**新的提交（Merge Commit）**。
- **内容**：这个新提交有两个“父亲”：一个是合并前的 `main`，一个是 `dev` 的顶端。
- **结果**：`main` 指针最后指向这个**新创建的提交**。
- **合并后用git log --graph --oneline查看**分叉后又汇合的曲线，**产生了一个新节点**。
- 内容上，`main` 吸收了 `dev` 的所有改动；但形式上，它拒绝“偷懒”直接跳过去，而是非要走个仪式感，新建一个记录。
- **删除 dev 分支后git log**历史中**依然能看到**曾经有过一个分支
---
**3.为什么要多此一举“新开一个”？**
既然“直接指向”更简单，为什么还要选 `--no-ff` 呢？

|**特性**|**--no-ff 的价值**|
|---|---|
|**保留证据**|历史记录里会有一条清晰的“弧线”，告诉你：这部分代码是在分支上完成的。|
|**方便回滚**|如果这个功能上线后发现全是 BUG，你可以直接撤销这一个“合并提交”，整个功能就从 `main` 消失了。|
|**团队规范**|在 GitHub 等平台协作时，这能让其他人一眼看出哪些提交属于同一个任务。|

|            ff            |            no-ff            |
| :----------------------: | :-------------------------: |
|  ![[合并ff.png]]  |  ![[合并no-ff.png]]  |
| ![[合并ff显示.png]] | ![[合并no-ff显示.png]] |

# Bug分支
- 每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。
- 要在哪个分支上修复bug，就要先切换到该分支，然后在该分支上创建临时分支并进入该临时分支。

**1.首先保存当前工作现场**
- 如果当前分支有**没提交的修改**(即add后但是未commit)，直接切换分支（`git checkout` 或 `git switch`）有时会报错，或者会把这些乱七八糟的修改带到另一个分支去。
- 需要git stash保存这些未commit的工作，同时工作区会恢复到上一次commit的状态，暂存区清空。
```bash
# 先保存该分支dev
git stash

# bug修好后，重新回到该分支dev后，先查看
git stash list

# 取出近一次贮藏的内容恢复到工作区并删除这条记录
git stash pop   # 默认最近的那个

# 或者取出并保留
git stash apply # 默认最近的那个
git stash apply stash@{2}

```
假设 `file1.txt` 在上一次 commit 时的内容是 `A`，把它改成了 `A + B`。
- 使用git status查询文件状态颜色：
- 文件add 过（绿色）
- 文件未 add 过（红色）

| **动作**                      | **file1.txt 里的实际内容** | **git status 看到的形态**              |
| --------------------------- | -------------------- | --------------------------------- |
| **1. 你改完代码并 `git add`**     | **A + B**            | 绿色（Staged）                        |
| **2. 执行 `git stash` 后**     | **A** (回到了上次 commit) | 干净（Clean）                         |
| **3. 执行 `git stash pop` 后** | **A + B** (你的代码回来了！) | **红色** (Modified，默认不保留绿色状态)，即未add |

**2.切换到需要debug的分支，并在该分支上创建临时分支**
```bash
# 先保存该分支dev
git stash

# 切换到需要debug的分支main
git switch main

# 创建临时分支issue-101以debug
git switch -c issue-101

# ......debug后提交
git commit -m "fix bug 101"

# debug完后回到main分支合并以修复bug
git switch main
git merge --no-ff -m "merged bug fix 101" issue-101
git branch -d issue-101

# 修复完后接着回到原分支dev干活
git switch dev


# 先同步修复到dev：既然main分支有 Bug，正在开发的dev分支（它是从旧的main分出去了）也带有这个同样的 Bug，所以也需要修复
# 拣选（Cherry-pick）
git log --graph --oneline --all #查看修复Bug的Commit ID(比如4c805e2)，找到"fix bug 101"对应的；git log --oneline --all也行
git cherry-pick 4c805e2 # 把 4c805e2 记录的改动内容，在 dev 分支上重新演练一遍，并生成一个新的提交点（即这一步包含了git commit）

# 再用stash 相关指令查看dev分支保存的内容
git stash list
git stash pop

```

# Feature分支
每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。
如果要丢弃一个没有被合并过的分支，可以通过`git branch -D <name>`强行删除。
- 假设开发代号为Vulcan的新功能，开发完成后（即feature-vulcan分支**已经执行过git commit了**），但此时接到上级命令，因经费不足，**新功能必须取消，所以需要强行删除feature-vulcan分支**
- 需要使用大写的-D参数强行删除分支feature-vulcan
- feature-vulcan分支**未执行过git commit时，-d就可以删除掉**：git branch -d feature-vulcan
```bash
# feature-vulcan分支还没有被合并，普通删除会失败，如果要强行删除，需要使用大写的-D参数
git branch -D feature-vulcan # 注意-d会删除失败，因为分支未合并，所以只能用-D删除
```

# 多人协作
多人协作的工作模式通常是这样：
```bash
# 克隆远程仓库
git clone git@github.com:michaelliao/learngit.git
cd learngit
git fetch origin # 同步远程分支最新状态（可选但推荐）
# 创建并切换到本地 dev 分支（同时关联本地dev分支到远程 origin/dev）
git checkout -b dev origin/dev 

# 关联好后查询本地分支及关联的远程分支
git branch -vv
```

1. 首先，可以尝试用`git push origin <branch-name>`推送自己的修改：git push origin dev
2. 如果推送失败，则因为远程分支比你的本地更新，需要先用`git pull`试图合并：git pull
3. 如果合并有冲突，则解决冲突，并在本地提交；
4. 没有冲突或者解决掉冲突后，再用`git push origin <branch-name>`推送就能成功:git push origin dev

如果`git pull`提示`no tracking information`，则说明本地分支和远程分支的链接关系没有创建，用命令`git branch --set-upstream-to <branch-name> origin/<branch-name>`：绑定本地dev分支和远程仓库的dev分支
* git branch --set-upstream-to=origin/dev dev


# rebase变基
`rebase` 是 “复用旧提交”，所以不需要commit
`git rebase --continue` 的唯一前提：**当前 rebase 暂停时，终端提示的所有冲突文件，都已解决冲突并执行 git add**。
- 相当于把远程的新提交 “拉到本地”，让你的本地提交 “接在” 远程提交后面（相当于 “先同步同事的代码，再把你的代码放在后面”）
1. 你执行 `git pull --rebase` 后，Git 会先把你本地的所有未推送提交 “暂存” 起来；
2. 然后把远程的新提交拉取并应用到本地分支；
3. 再逐个把你 “暂存” 的本地提交，重新应用到当前分支（这一步如果冲突，就需要你解决）；
4. 你解决冲突后执行 `git add 冲突文件`，只是告诉 Git“这个冲突已经处理好了，可以继续往下走”；
5. 接着 `git rebase --continue`，Git 会自动把你原来的提交记录 “贴” 上去（保留原来的提交信息、作者、时间戳），不需要你再手动 `commit`。
**先 git pull --rebase 再 git push 的流程（相比较先 git pull 再 git push），正是同时实现了 “方便解决冲突” 和 “保持提交记录整洁” 这两个核心目标**
```bash
# 1. 拉取远程代码并变基（把本地提交“接在”远程最新提交后面）
git pull --rebase origin 分支名  # 建议明确指定分支（如 main/dev），避免默认分支出错

# 2. 若出现冲突，终端会提示“自动合并失败”，此时：
# - 打开冲突文件，找到 <<<<<<< HEAD（远程代码）、=======、>>>>>>> 你的提交信息（本地代码）
# - 手动编辑保留正确代码，删除冲突标记（<<<<<<、=======、>>>>>>>）
# - 标记冲突已解决
git add 冲突文件路径  # 单个文件：git add src/index.js；所有冲突文件：git add .

# 3. 继续完成 rebase（直到所有本地提交都处理完冲突）
git rebase --continue

# 4. 若中途想放弃，执行回滚
# git rebase --abort

# 5. 推送本地提交到远程（关键补充：首次 rebase 后推送可能需要 --force-with-lease）
# 情况A：本地提交从未推送到远程过 → 直接推送（无风险）
git push origin 分支名

# 情况B：本地提交之前已推送到远程，且执行了 rebase（改写了历史）→ 必须用 --force-with-lease（安全强制推送）
git push --force-with-lease origin 分支名  # 优先用这个，比直接 --force 安全（避免覆盖他人提交）
# 若提示权限不足或冲突，可确认无他人修改后用（慎用）：git push --force origin 分支名
```
